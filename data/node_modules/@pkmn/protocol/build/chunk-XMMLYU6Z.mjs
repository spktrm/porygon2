// src/index.ts
function toID(s) {
  return ("" + s).toLowerCase().replace(/[^a-z0-9]+/g, "");
}
var ignoreKwArgsSimple = /* @__PURE__ */ new Set([
  "chatmsg",
  "chatmsg-raw",
  "raw",
  "error",
  "html",
  "inactive",
  "inactiveoff",
  "warning",
  "title",
  "formats",
  "selectorhtml",
  "pagehtml",
  "fieldhtml",
  "controlshtml",
  "bigerror",
  "debug",
  "tier",
  "challstr",
  "popup",
  "",
  "customgroups",
  "notify"
]);
var Protocol = new class {
  constructor() {
    // NOTE: An object is used here to get TypeScript to perform exhaustiveness checking
    this.ARGS = {
      "|init|": 1,
      "|title|": 1,
      "|users|": 1,
      "||": 1,
      "|html|": 1,
      "|uhtml|": 1,
      "|pagehtml|": 1,
      "|uhtmlchange|": 1,
      "|join|": 1,
      "|leave|": 1,
      "|name|": 1,
      "|chat|": 1,
      "|notify|": 1,
      "|:|": 1,
      "|c:|": 1,
      "|t:|": 1,
      "|battle|": 1,
      "|popup|": 1,
      "|pm|": 1,
      "|usercount|": 1,
      "|nametaken|": 1,
      "|challstr|": 1,
      "|updateuser|": 1,
      "|formats|": 1,
      "|updatesearch|": 1,
      "|message|": 1,
      "|updatechallenges|": 1,
      "|queryresponse|": 1,
      "|unlink|": 1,
      "|raw|": 1,
      "|error|": 1,
      "|bigerror|": 1,
      "|chatmsg|": 1,
      "|chatmsg-raw|": 1,
      "|controlshtml|": 1,
      "|fieldhtml|": 1,
      "|debug|": 1,
      "|deinit|": 1,
      "|selectorhtml|": 1,
      "|refresh|": 1,
      "|tempnotify|": 1,
      "|tempnotifyoff|": 1,
      "|noinit|": 1,
      "|hidelines|": 1,
      "|expire|": 1,
      "|askreg|": 1,
      "|tournament|create|": 1,
      "|tournament|update|": 1,
      "|tournament|updateEnd|": 1,
      "|tournament|error|": 1,
      "|tournament|forceend|": 1,
      "|tournament|join|": 1,
      "|tournament|leave|": 1,
      "|tournament|replace|": 1,
      "|tournament|start|": 1,
      "|tournament|disqualify|": 1,
      "|tournament|battlestart|": 1,
      "|tournament|battleend|": 1,
      "|tournament|end|": 1,
      "|tournament|scouting|": 1,
      "|tournament|autostart|": 1,
      "|tournament|autodq|": 1,
      "|player|": 1,
      "|teamsize|": 1,
      "|gametype|": 1,
      "|gen|": 1,
      "|tier|": 1,
      "|rated|": 1,
      "|seed|": 1,
      "|rule|": 1,
      "|teampreview|": 1,
      "|custom|": 1,
      "|clearpoke|": 1,
      "|poke|": 1,
      "|start|": 1,
      "|done|": 1,
      "|request|": 1,
      "|inactive|": 1,
      "|inactiveoff|": 1,
      "|upkeep|": 1,
      "|turn|": 1,
      "|win|": 1,
      "|tie|": 1,
      "|move|": 1,
      "|switch|": 1,
      "|drag|": 1,
      "|detailschange|": 1,
      "|replace|": 1,
      "|swap|": 1,
      "|cant|": 1,
      "|faint|": 1,
      "|-formechange|": 1,
      "|-fail|": 1,
      "|-block|": 1,
      "|-notarget|": 1,
      "|-miss|": 1,
      "|-damage|": 1,
      "|-heal|": 1,
      "|-sethp|": 1,
      "|-status|": 1,
      "|-curestatus|": 1,
      "|-cureteam|": 1,
      "|-boost|": 1,
      "|-unboost|": 1,
      "|-setboost|": 1,
      "|-swapboost|": 1,
      "|-invertboost|": 1,
      "|-clearboost|": 1,
      "|-clearallboost|": 1,
      "|-clearpositiveboost|": 1,
      "|-ohko|": 1,
      "|-clearnegativeboost|": 1,
      "|-copyboost|": 1,
      "|-weather|": 1,
      "|-fieldstart|": 1,
      "|-fieldend|": 1,
      "|-sidestart|": 1,
      "|-sideend|": 1,
      "|-start|": 1,
      "|-end|": 1,
      "|-crit|": 1,
      "|-supereffective|": 1,
      "|-resisted|": 1,
      "|-immune|": 1,
      "|-item|": 1,
      "|-enditem|": 1,
      "|-ability|": 1,
      "|-endability|": 1,
      "|-transform|": 1,
      "|-mega|": 1,
      "|-primal|": 1,
      "|-burst|": 1,
      "|-zpower|": 1,
      "|-zbroken|": 1,
      "|-activate|": 1,
      "|-fieldactivate|": 1,
      "|-hint|": 1,
      "|-center|": 1,
      "|-message|": 1,
      "|-combine|": 1,
      "|-waiting|": 1,
      "|-prepare|": 1,
      "|-mustrecharge|": 1,
      "|-hitcount|": 1,
      "|-singlemove|": 1,
      "|-singleturn|": 1,
      "|-anim|": 1,
      "|warning|": 1,
      "|-candynamax|": 1,
      "|updatepoke|": 1,
      "|-swapsideconditions|": 1,
      "|-terastallize|": 1,
      "|sentchoice|": 1,
      "|customgroups|": 1
    };
    this.ARGS_WITH_KWARGS = {
      "|move|": 1,
      "|switch|": 1,
      "|cant|": 1,
      "|-formechange|": 1,
      "|-fail|": 1,
      "|-block|": 1,
      "|-damage|": 1,
      "|-heal|": 1,
      "|-sethp|": 1,
      "|-status|": 1,
      "|swap|": 1,
      "|-curestatus|": 1,
      "|-cureteam|": 1,
      "|-boost|": 1,
      "|-unboost|": 1,
      "|-setboost|": 1,
      "|-swapboost|": 1,
      "|-invertboost|": 1,
      "|-clearnegativeboost|": 1,
      "|-weather|": 1,
      "|-fieldstart|": 1,
      "|-fieldend|": 1,
      "|-sidestart|": 1,
      "|-singlemove|": 1,
      "|-sideend|": 1,
      "|-start|": 1,
      "|-end|": 1,
      "|-immune|": 1,
      "|-item|": 1,
      "|-enditem|": 1,
      "|-ability|": 1,
      "|-endability|": 1,
      "|-transform|": 1,
      "|-activate|": 1,
      "|-singleturn|": 1,
      "|-clearallboost|": 1,
      "|-anim|": 1,
      "|-copyboost|": 1,
      "|-clearboost|": 1,
      "|-miss|": 1
    };
  }
  *parse(data) {
    const lines = data.split("\n");
    let roomid = "";
    for (const [i, line] of lines.entries()) {
      if (i === 0 && line[0] === ">") {
        roomid = line.slice(1);
        continue;
      } else if (line) {
        const { args, kwArgs } = this.parseBattleLine(line);
        yield { roomid, args, kwArgs };
      }
    }
  }
  key(args, raw = false) {
    const key = args[0] === "tournament" ? `|${args[0]}|${args[1]}|` : `|${args[0]}|`;
    return raw || key in this.ARGS ? key : void 0;
  }
  parseLine(line, noDefault) {
    if (!line.startsWith("|"))
      return ["", line];
    if (line === "|")
      return ["done"];
    const index = line.indexOf("|", 1);
    const cmd = line.slice(1, index);
    if (ignoreKwArgsSimple.has(cmd))
      return upgradeArgs([cmd, line.slice(index + 1)]);
    switch (cmd) {
      case "c":
      case "chat":
      case "uhtml":
      case "uhtmlchange":
        const index2a = line.indexOf("|", index + 1);
        return upgradeArgs([cmd, line.slice(index + 1, index2a), line.slice(index2a + 1)]);
      case "c:":
      case "pm":
        const index2b = line.indexOf("|", index + 1);
        const index3b = line.indexOf("|", index2b + 1);
        return upgradeArgs([
          cmd,
          line.slice(index + 1, index2b),
          line.slice(index2b + 1, index3b),
          line.slice(index3b + 1)
        ]);
    }
    if (noDefault)
      return null;
    return upgradeArgs(line.slice(1).split("|"));
  }
  parseBattleLine(line) {
    let args = Protocol.parseLine(line, true);
    if (args)
      return { args, kwArgs: {} };
    args = line.slice(1).split("|");
    const kwArgs = {};
    while (args.length > 1) {
      const lastArg = args[args.length - 1];
      if (lastArg.charAt(0) !== "[")
        break;
      const bracketPos = lastArg.indexOf("]");
      if (bracketPos <= 0)
        break;
      kwArgs[lastArg.slice(1, bracketPos)] = lastArg.slice(bracketPos + 1).trim() || true;
      args.pop();
    }
    return upgradeBattleArgs({
      args: upgradeArgs(args),
      kwArgs
    });
  }
  parsePokemonIdent(pokemon) {
    const index = pokemon.indexOf(":");
    const position = pokemon.slice(0, index);
    const name = pokemon.slice(index + 2);
    let player;
    let letter;
    if (position.length < 3) {
      player = position;
      letter = null;
    } else {
      player = position.slice(0, 2);
      letter = position.charAt(2);
    }
    return { player, position: letter, name };
  }
  parseDetails(name, ident, details = "", output = {}) {
    output.details = details;
    const isTeamPreview = !name;
    output.name = name;
    output.speciesForme = name;
    output.level = 100;
    output.shiny = false;
    output.gender = void 0;
    output.ident = !isTeamPreview ? ident : "";
    output.searchid = !isTeamPreview ? `${ident}|${details}` : "";
    const splitDetails = details.split(", ");
    if (splitDetails[splitDetails.length - 1].startsWith("tera:")) {
      output.terastallized = splitDetails[splitDetails.length - 1].slice(5);
      splitDetails.pop();
    }
    if (splitDetails[splitDetails.length - 1] === "shiny") {
      output.shiny = true;
      splitDetails.pop();
    }
    const gender = splitDetails[splitDetails.length - 1];
    if (gender === "M" || gender === "F") {
      output.gender = gender;
      splitDetails.pop();
    }
    if (splitDetails[1])
      output.level = parseInt(splitDetails[1].substr(1)) || 100;
    if (splitDetails[0])
      output.speciesForme = splitDetails[0];
    return output;
  }
  parseHealth(hpstring, output = {}) {
    const [hp, status] = hpstring.split(" ");
    output.hpcolor = "";
    if (hp === "0" || hp === "0.0") {
      if (!output.maxhp)
        output.maxhp = 100;
      output.hp = 0;
    } else if (hp.indexOf("/") > 0) {
      const [curhp, maxhp] = hp.split("/");
      if (isNaN(parseFloat(curhp)) || isNaN(parseFloat(maxhp))) {
        return null;
      }
      output.hp = parseFloat(curhp);
      output.maxhp = parseFloat(maxhp);
      if (output.hp > output.maxhp)
        output.hp = output.maxhp;
      const colorchar = maxhp.slice(-1);
      if (colorchar === "y" || colorchar === "g") {
        output.hpcolor = colorchar;
      }
    } else if (!isNaN(parseFloat(hp))) {
      if (!output.maxhp)
        output.maxhp = 100;
      output.hp = output.maxhp * parseFloat(hp) / 100;
    }
    if (!status) {
      output.status = void 0;
    } else if (status === "par" || status === "brn" || status === "slp" || status === "frz" || status === "tox") {
      output.status = status;
    } else if (status === "psn" && output.status !== "tox") {
      output.status = status;
    } else if (status === "fnt") {
      output.hp = 0;
      output.fainted = true;
    }
    return output;
  }
  parseEffect(effect, fn = (s) => s.trim()) {
    if (!effect)
      return { name: fn("") };
    if (effect.startsWith("item:") || effect.startsWith("move:")) {
      return { name: fn(effect.slice(5)), type: effect.slice(0, 4) };
    } else if (effect.startsWith("ability:")) {
      return { name: fn(effect.slice(8)), type: "ability" };
    }
    return { name: fn(effect) };
  }
  parseRequest(json) {
    const request = JSON.parse(json);
    if (!request.requestType) {
      request.requestType = "move";
      if (request.forceSwitch) {
        request.requestType = "switch";
      } else if (request.teamPreview) {
        request.requestType = "team";
      } else if (request.wait) {
        request.requestType = "wait";
      }
    }
    if (request.requestType === "wait")
      request.noCancel = true;
    if (request.side) {
      for (const pokemon of request.side.pokemon) {
        this.parseDetails(pokemon.ident.substr(4), pokemon.ident, pokemon.details, pokemon);
        this.parseHealth(pokemon.condition, pokemon);
        pokemon.ability = pokemon.ability || pokemon.baseAbility;
      }
    }
    if (request.active) {
      request.active = request.active.map((active, i) => request.side.pokemon[i].fainted ? null : active);
      for (const active of request.active) {
        if (!active)
          continue;
        for (const move of active.moves) {
          if (move.move)
            move.name = move.move;
          move.id = toID(move.name);
        }
        if (active.maxMoves) {
          if (active.maxMoves.maxMoves) {
            active.canGigantamax = active.maxMoves.gigantamax;
            active.maxMoves = active.maxMoves.maxMoves;
          }
          for (const move of active.maxMoves) {
            move.id = move.move;
          }
        }
        if (active.canZMove) {
          active.zMoves = active.canZMove;
          for (const move of active.zMoves) {
            if (!move)
              continue;
            if (move.move)
              move.name = move.move;
            move.id = toID(move.name);
          }
        }
      }
    }
    return request;
  }
  parseChallenges(json) {
    return JSON.parse(json);
  }
  parseSearchState(json) {
    return JSON.parse(json);
  }
  parseTournamentUpdate(json) {
    return JSON.parse(json);
  }
  parseCustomGroupsJSON(json) {
    return JSON.parse(json);
  }
  parseNameParts(text) {
    let group = "";
    if (!/[A-Za-z0-9]/.test(text.charAt(0))) {
      group = text.charAt(0);
      text = text.slice(1);
    }
    let name = text;
    const atIndex = text.indexOf("@");
    let status = "";
    let away = false;
    if (atIndex > 0) {
      name = text.slice(0, atIndex);
      status = text.slice(atIndex + 1);
      if (status.startsWith("!")) {
        away = true;
        status = status.slice(1);
      }
    }
    return { group, name, away, status };
  }
}();
function upgradeArgs(args) {
  switch (args[0]) {
    case "name":
    case "n":
    case "N": {
      const [cmd, user, oldid] = args;
      return ["name", user, oldid, cmd === "N"];
    }
    case "chat":
    case "c": {
      const [, user, message] = args;
      return ["chat", user, message];
    }
    case "join":
    case "j":
    case "J": {
      const [cmd, user] = args;
      return ["join", user, cmd === "J"];
    }
    case "leave":
    case "l":
    case "L": {
      const [cmd, user] = args;
      return ["leave", user, cmd === "L"];
    }
    case "battle":
    case "b": {
      const [, roomid, user1, user2] = args;
      return ["battle", roomid, user1, user2];
    }
  }
  return args;
}
var ACTIVATE_BLOCKABLE = /* @__PURE__ */ new Set([
  "ingrain",
  "quickguard",
  "wideguard",
  "craftyshield",
  "matblock",
  "protect",
  "mist",
  "safeguard",
  "electricterrain",
  "mistyterrain",
  "psychicterrain",
  "telepathy",
  "stickyhold",
  "suctioncups",
  "aromaveil",
  "flowerveil",
  "sweetveil",
  "disguise",
  "safetygoggles",
  "protectivepads"
]);
var CANT_BLOCKABLE = /* @__PURE__ */ new Set([
  "ability: Damp",
  "ability: Dazzling",
  "ability: Queenly Majesty",
  "ability: Armor Tail"
]);
var STARTABLE = /* @__PURE__ */ new Set([
  "thundercage",
  "clamp",
  "whirlpool",
  "firespin",
  "magmastorm",
  "sandtomb",
  "infestation",
  "trapped",
  "bind",
  "snaptrap",
  "wrap"
]);
var NUMBERABLE = /* @__PURE__ */ new Set([
  "eeriespell",
  "gmaxdepletion",
  "spite",
  "grudge",
  "forewarn",
  "sketch",
  "leppaberry",
  "mysteryberry"
]);
var HEALING = /* @__PURE__ */ new Set(["dryskin", "eartheater", "voltabsorb", "waterabsorb"]);
function upgradeBattleArgs({ args, kwArgs }) {
  switch (args[0]) {
    case "-activate": {
      if (kwArgs.item || kwArgs.move || kwArgs.number || kwArgs.ability)
        return { args, kwArgs };
      const [, pokemon, e, arg3, arg4] = args;
      const effect = e;
      const target = kwArgs.of;
      const id = Protocol.parseEffect(effect, toID).name;
      if (kwArgs.block)
        return { args: ["-fail", pokemon], kwArgs };
      if (id === "sturdy") {
        return { args: ["-activate", pokemon, "ability: Sturdy"], kwArgs };
      }
      if (id === "wonderguard") {
        return {
          args: ["-immune", pokemon],
          kwArgs: { from: "ability: Wonder Guard" }
        };
      }
      if (id === "beatup" && kwArgs.of) {
        return { args, kwArgs: { name: kwArgs.of } };
      }
      if (ACTIVATE_BLOCKABLE.has(id)) {
        if (target) {
          kwArgs.of = pokemon;
          return { args: ["-block", target, effect, arg3 || ""], kwArgs };
        }
        return {
          args: [
            "-block",
            pokemon,
            effect,
            arg3 || ""
          ],
          kwArgs
        };
      }
      if (id === "charge") {
        return {
          args: ["-singlemove", pokemon, "Charge"],
          kwArgs: { of: target || void 0 }
        };
      }
      if (STARTABLE.has(id)) {
        return {
          args: ["-start", pokemon, effect],
          kwArgs: { of: target || "" }
        };
      }
      if (id === "fairylock")
        return { args: ["-fieldactivate", effect], kwArgs: {} };
      if (id === "symbiosis" || id === "poltergeist") {
        kwArgs.item = arg3;
      } else if (id === "magnitude") {
        kwArgs.number = arg3;
      } else if (id === "skillswap" || id === "mummy" || id === "lingeringaroma") {
        kwArgs.ability = arg3;
        kwArgs.ability2 = arg4;
      } else if (id === "wanderingspirit") {
        if (arg3) {
          kwArgs.ability = arg3;
          kwArgs.ability2 = arg4;
        } else {
          return {
            args: [
              "-ability",
              pokemon,
              "Wandering Spirit"
            ],
            kwArgs: {}
          };
        }
      } else if (NUMBERABLE.has(id)) {
        kwArgs.move = arg3;
        kwArgs.number = arg4;
      }
      return {
        args: [
          "-activate",
          pokemon,
          effect,
          target || ""
        ],
        kwArgs
      };
    }
    case "-start": {
      if (kwArgs.from === "Protean" || kwArgs.from === "Color Change") {
        kwArgs.from = "ability:" + kwArgs.from;
      }
      break;
    }
    case "move": {
      if (kwArgs.from === "Magic Bounce")
        kwArgs.from = "ability: Magic Bounce";
      break;
    }
    case "cant": {
      const [, pokemon, effect, move] = args;
      if (CANT_BLOCKABLE.has(effect)) {
        return {
          args: [
            "-block",
            pokemon,
            effect,
            move,
            kwArgs.of || ""
          ],
          kwArgs: {}
        };
      }
      break;
    }
    case "-heal": {
      const id = Protocol.parseEffect(kwArgs.from, toID).name;
      if (HEALING.has(id))
        kwArgs.of = "";
      break;
    }
    case "gen": {
      const [, num] = args;
      return { args: ["gen", Number(num)], kwArgs: {} };
    }
    case "-restoreboost": {
      args[0] = "-clearnegativeboost";
      break;
    }
    case "-nothing":
      args = [
        "-activate",
        "",
        "move: Splash"
      ];
  }
  return { args, kwArgs };
}

export {
  ignoreKwArgsSimple,
  Protocol
};
//# sourceMappingURL=chunk-XMMLYU6Z.mjs.map