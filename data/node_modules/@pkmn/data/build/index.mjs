// index.ts
var DEFAULT_EXISTS = (d) => {
  if (!d.exists) return false;
  if ("isNonstandard" in d && d.isNonstandard) return false;
  if (d.kind === "Ability" && d.id === "noability") return false;
  return !("tier" in d && ["Illegal", "Unreleased"].includes(d.tier));
};
var tr = (num, bits = 0) => bits ? (num >>> 0) % 2 ** bits : num >>> 0;
function assignWithout(a, b, exclude) {
  for (const key in b) {
    if (Object.prototype.hasOwnProperty.call(b, key) && !exclude.has(key)) {
      a[key] = b[key];
    }
  }
  return a;
}
function toID(text) {
  if (text == null ? void 0 : text.id) text = text.id;
  if (typeof text !== "string" && typeof text !== "number") return "";
  return ("" + text).toLowerCase().replace(/[^a-z0-9]+/g, "");
}
var _Generations = class _Generations {
  constructor(dex, exists = _Generations.DEFAULT_EXISTS) {
    /* private */
    this.cache = /* @__PURE__ */ Object.create(null);
    this.dex = dex;
    this.exists = exists;
  }
  get(g) {
    const gen = typeof g === "string" ? parseInt(g.slice(g.search(/\d/))) : g;
    if (isNaN(+gen)) throw new Error(`Invalid gen ${g}`);
    if (this.cache[gen]) return this.cache[gen];
    return this.cache[gen] = new Generation(this.dex.forGen(gen), (d) => this.exists(d, gen));
  }
  *[Symbol.iterator]() {
    for (let gen = 1; gen <= 9; gen++) {
      yield this.get(gen);
    }
  }
};
_Generations.DEFAULT_EXISTS = DEFAULT_EXISTS;
var Generations = _Generations;
var Generation = class {
  static get(dex, g, exists = DEFAULT_EXISTS) {
    return new Generations(dex, exists).get(g);
  }
  constructor(dex, exists) {
    this.dex = dex;
    this.exists = exists;
    this.abilities = new Abilities(this.dex, this.exists);
    this.items = new Items(this.dex, this.exists);
    this.moves = new Moves(this.dex, this.exists);
    this.species = new Species(this.dex, this.exists);
    this.natures = new Natures(this.dex, this.exists);
    this.types = new Types(this.dex, this.exists);
    this.learnsets = new Learnsets(this, this.dex, this.exists);
    this.conditions = new Conditions(this.dex, this.exists);
    this.stats = new Stats(this.dex);
  }
  get num() {
    return this.dex.gen;
  }
  toString() {
    return `[Generation:${this.num}]`;
  }
  toJSON() {
    return this.toString();
  }
};
var Abilities = class {
  constructor(dex, exists) {
    this.dex = dex;
    this.exists = exists;
  }
  get(name) {
    const ability = this.dex.abilities.get(name);
    return this.exists(ability) ? ability : void 0;
  }
  *[Symbol.iterator]() {
    for (const ability in this.dex.data.Abilities) {
      const a = this.get(ability);
      if (a) yield a;
    }
  }
};
var Items = class {
  constructor(dex, exists) {
    this.dex = dex;
    this.exists = exists;
  }
  get(name) {
    const item = this.dex.items.get(name);
    return this.exists(item) ? item : void 0;
  }
  *[Symbol.iterator]() {
    for (const item in this.dex.data.Items) {
      const i = this.get(item);
      if (i) yield i;
    }
  }
};
var Moves = class {
  constructor(dex, exists) {
    this.dex = dex;
    this.exists = exists;
  }
  get(name) {
    const move = this.dex.moves.get(name);
    return this.exists(move) ? move : void 0;
  }
  *[Symbol.iterator]() {
    for (const move in this.dex.data.Moves) {
      const m = this.get(move);
      if (m) yield m;
    }
  }
};
var Species = class {
  constructor(dex, exists) {
    /* private */
    this.cache = /* @__PURE__ */ Object.create(null);
    this.dex = dex;
    this.exists = exists;
  }
  get(name) {
    const species = this.dex.species.get(name);
    if (!this.exists(species)) return void 0;
    const id = species.speciesid || species.id;
    const cached = this.cache[id];
    if (cached) return cached;
    return this.cache[id] = new Specie(this.dex, this.exists, species);
  }
  *[Symbol.iterator]() {
    for (const species in this.dex.data.Species) {
      const s = this.get(species);
      if (s) yield s;
    }
  }
};
var _Specie = class _Specie {
  constructor(dex, exists, species) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    assignWithout(this, species, _Specie.EXCLUDE);
    this.dex = dex;
    if (this.dex.gen >= 2) {
      this.gender = species.gender;
      this.genderRatio = species.genderRatio;
    } else {
      this.genderRatio = { M: 0, F: 0 };
    }
    if (this.dex.gen >= 3) {
      this.abilities = { 0: species.abilities[0] };
      if (species.abilities[1] && this.dex.abilities.get(species.abilities[1]).gen <= this.dex.gen) {
        this.abilities[1] = species.abilities[1];
      }
      if (this.dex.gen >= 5 && species.abilities.H) this.abilities.H = species.abilities.H;
      if (this.dex.gen >= 7 && species.abilities.S) this.abilities.S = species.abilities.S;
    } else {
      this.abilities = { 0: "" };
    }
    this.evos = (_a = species.evos) == null ? void 0 : _a.filter((s) => exists(this.dex.species.get(s)));
    this.nfe = !!((_b = this.evos) == null ? void 0 : _b.length);
    if (!this.nfe) this.evos = void 0;
    this.cosmeticFormes = (_c = species.cosmeticFormes) == null ? void 0 : _c.filter((s) => exists(this.dex.species.get(s)));
    if (!((_d = this.cosmeticFormes) == null ? void 0 : _d.length)) this.cosmeticFormes = void 0;
    this.otherFormes = (_e = species.otherFormes) == null ? void 0 : _e.filter((s) => exists(this.dex.species.get(s)));
    if (!((_f = this.otherFormes) == null ? void 0 : _f.length)) this.otherFormes = void 0;
    this.formeOrder = (_g = species.formeOrder) == null ? void 0 : _g.filter((s) => exists(this.dex.species.get(s)));
    if (!this.formeOrder || this.formeOrder.length <= 1) this.formeOrder = void 0;
    this.formes = (_h = this.formeOrder) == null ? void 0 : _h.filter((s) => this.dex.species.get(s).isNonstandard !== "Gigantamax");
    this.prevo = species.prevo && exists(this.dex.species.get(species.prevo)) ? species.prevo : void 0;
  }
  get formeNum() {
    return this.baseSpecies === this.name ? this.formeOrder ? this.formeOrder.findIndex((name) => name === this.name) : 0 : this.dex.species.get(this.baseSpecies).formeOrder.findIndex(
      (name) => name === (this.isNonstandard === "Gigantamax" ? this.baseSpecies : this.name)
    );
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return assignWithout({}, this, /* @__PURE__ */ new Set(["dex"]));
  }
};
/* private */
_Specie.EXCLUDE = /* @__PURE__ */ new Set([
  "abilities",
  "cosmeticFormes",
  "evos",
  "formeOrder",
  "gender",
  "genderRatio",
  "nfe",
  "otherFormes",
  "prevo"
]);
var Specie = _Specie;
var Conditions = class {
  constructor(dex, exists) {
    this.dex = dex;
    this.exists = exists;
  }
  get(name) {
    const condition = this.dex.conditions.get(name);
    return this.exists(condition) ? condition : void 0;
  }
};
var Natures = class {
  constructor(dex, exists) {
    this.dex = dex;
    this.exists = exists;
  }
  get(name) {
    if (this.dex.gen < 3) return void 0;
    const nature = this.dex.natures.get(name);
    return this.exists(nature) ? nature : void 0;
  }
  *[Symbol.iterator]() {
    for (const nature in this.dex.data.Natures) {
      const n = this.get(nature);
      if (n) yield n;
    }
  }
};
var EFFECTIVENESS = {
  "-3": 0.125,
  "-2": 0.25,
  "-1": 0.5,
  "0": 1,
  "1": 2,
  "2": 4,
  "3": 8
};
var Types = class {
  constructor(dex, exists) {
    /* private */
    this.cache = /* @__PURE__ */ Object.create(null);
    this.dex = dex;
    this.exists = exists;
    this.unknown = new Type({
      effectType: "Type",
      kind: "Type",
      // Regrettably PS ID's can't represent '???'
      id: "",
      name: "???",
      // Technically this only exists as a true type in Gens 2-4, but there are moves dealing
      // typeless damage in Gen 1 so we include it there.
      exists: dex.gen <= 4,
      gen: 1,
      // This gets filled in for us by Type's constructor
      damageTaken: {},
      HPivs: {},
      HPdvs: {}
    }, dex, this);
  }
  get(name) {
    if (name === "???") return this.unknown;
    const type = this.dex.types.get(name);
    if (!this.exists(type)) return void 0;
    const cached = this.cache[type.id];
    if (cached) return cached;
    return this.cache[type.id] = new Type(type, this.dex, this);
  }
  *[Symbol.iterator]() {
    for (const type in this.dex.data.Types) {
      const t = this.get(type);
      if (t) yield t;
    }
    if (this.dex.gen >= 2 && this.dex.gen <= 4) {
      yield this.unknown;
    }
  }
  getHiddenPower(ivs) {
    return this.dex.getHiddenPower(ivs);
  }
  canDamage(source, target) {
    return this.dex.getImmunity(source, target);
  }
  totalEffectiveness(source, target) {
    if (!this.canDamage(source, target)) return 0;
    const e = `${this.dex.getEffectiveness(source, target)}`;
    return EFFECTIVENESS[e];
  }
};
var DAMAGE_TAKEN = [1, 2, 0.5, 0];
var SPECIAL = ["Fire", "Water", "Grass", "Electric", "Ice", "Psychic", "Dark", "Dragon"];
var Type = class {
  constructor(type, dex, types) {
    Object.assign(this, type);
    this.types = types;
    this.category = this.name === "Fairy" ? void 0 : SPECIAL.includes(this.name) ? "Special" : "Physical";
    this.effectiveness = { "???": 1 };
    for (const k in dex.data.Types) {
      const t = k.charAt(0).toUpperCase() + k.slice(1);
      this.effectiveness[t] = DAMAGE_TAKEN[dex.data.Types[k].damageTaken[this.name] || 0];
    }
  }
  canDamage(target) {
    return this.types.canDamage(this.name, target);
  }
  totalEffectiveness(target) {
    return this.types.totalEffectiveness(this.name, target);
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return assignWithout({}, this, /* @__PURE__ */ new Set(["types"]));
  }
};
var GEN3_HMS = /* @__PURE__ */ new Set(["cut", "fly", "surf", "strength", "flash", "rocksmash", "waterfall", "dive"]);
var GEN4_HMS = /* @__PURE__ */ new Set(["cut", "fly", "surf", "strength", "rocksmash", "waterfall", "rockclimb"]);
var Learnsets = class {
  constructor(gen, dex, exists) {
    /* private */
    this.cache = /* @__PURE__ */ Object.create(null);
    this.gen = gen;
    this.dex = dex;
    this.exists = exists;
  }
  async get(name) {
    const learnset = await this.dex.learnsets.get(toID(name));
    return this.exists(learnset) ? learnset : void 0;
  }
  async *[Symbol.iterator]() {
    if (!this.dex.data.Learnsets) await this.dex.learnsets.get("LOAD");
    for (const id in this.dex.data.Learnsets) {
      const l = await this.get(id);
      if (l) yield l;
    }
  }
  async *all(species) {
    let id = species.id;
    let learnset = await this.get(id);
    if (!learnset) {
      id = typeof species.battleOnly === "string" && species.battleOnly !== species.baseSpecies ? toID(species.battleOnly) : toID(species.baseSpecies);
      learnset = await this.get(id);
    }
    while (learnset) {
      yield learnset;
      if (id === "lycanrocdusk" || species.id === "rockruff" && id === "rockruff") {
        id = "rockruffdusk";
      } else if (species.id === "gastrodoneast") {
        id = "gastrodon";
      } else if (species.id === "pumpkaboosuper") {
        id = "pumpkaboo";
      } else {
        id = toID(species.battleOnly || species.changesFrom || species.prevo);
      }
      if (!id) break;
      const s = this.gen.species.get(id);
      if (!s) break;
      species = s;
      learnset = await this.get(id);
    }
  }
  // BUG: this only covers what Pokémon Showdown deems "teambuilder legality" - proper legality
  // checks/restriction enforcement requires @pkmn/sim's TeamValidator.
  async learnable(name, restriction) {
    const species = this.gen.species.get(name);
    if (!species) return void 0;
    if (!restriction) {
      const cached = this.cache[species.id];
      if (cached) return cached;
    }
    const moves = {};
    for await (const learnset of this.all(species)) {
      if (learnset.learnset) {
        for (const moveid in learnset.learnset) {
          const move = this.gen.moves.get(moveid);
          if (move) {
            const sources = learnset.learnset[moveid];
            if (this.isLegal(move, sources, restriction || this.gen)) {
              const filtered = sources.filter((s) => +s.charAt(0) <= this.gen.num);
              if (!filtered.length) continue;
              if (moves[move.id]) {
                const unique = [];
                loop: for (const source of filtered) {
                  const prefix = source.slice(0, 2);
                  for (const s of moves[move.id]) if (s.startsWith(prefix)) continue loop;
                  unique.push(source);
                }
                moves[move.id].push(...unique);
              } else {
                moves[move.id] = filtered;
              }
            }
          }
        }
      }
    }
    if (!restriction) this.cache[species.id] = moves;
    return moves;
  }
  // BUG: this only covers what Pokémon Showdown deems "teambuilder legality" - proper legality
  // checks/restriction enforcement requires @pkmn/sim's TeamValidator.
  async canLearn(name, move, restriction) {
    var _a;
    const species = this.gen.species.get(name);
    if (!species) return false;
    move = typeof move === "string" && this.gen.moves.get(move) || move;
    if (typeof move === "string") return false;
    for await (const learnset of this.all(species)) {
      if (this.isLegal(move, (_a = learnset.learnset) == null ? void 0 : _a[move.id], restriction || this.gen)) {
        return true;
      }
    }
    return false;
  }
  // BUG: this only covers what Pokémon Showdown deems "teambuilder legality" - proper legality
  // checks/restriction enforcement requires @pkmn/sim's TeamValidator.
  isLegal(move, sources, gen) {
    if (!sources) return void 0;
    const gens = sources.map((x) => Number(x[0]));
    const minGen = Math.min(...gens);
    const vcOnly = minGen === 7 && sources.every((x) => x[0] !== "7" || x === "7V") || minGen === 8 && sources.every((x) => x[0] !== "8" || x === "8V");
    if (gen === "Pentagon") return gens.includes(6);
    if (gen === "Plus") return gens.includes(7) && !vcOnly;
    if (gen === "Galar") return gens.includes(8) && !vcOnly;
    if (gen === "Paldea") return gens.includes(9);
    if (this.gen.num >= 3 && minGen <= 4 && (GEN3_HMS.has(move.id) || GEN4_HMS.has(move.id))) {
      let legalGens = "";
      let available = false;
      if (minGen === 3) {
        legalGens += "3";
        available = true;
      }
      if (available) available = !GEN3_HMS.has(move.id);
      if (available || gens.includes(4)) {
        legalGens += "4";
        available = true;
      }
      if (available) available = !GEN4_HMS.has(move.id);
      const minUpperGen = available ? 5 : Math.min(...gens.filter((g) => g > 4));
      legalGens += "0123456789".slice(minUpperGen);
      return legalGens.includes(`${gen.num}`);
    } else {
      return "0123456789".slice(minGen).includes(`${gen.num}`);
    }
  }
};
var STATS = ["hp", "atk", "def", "spe", "spa", "spd"];
var NAMES = {
  HP: "hp",
  hp: "hp",
  Attack: "atk",
  Atk: "atk",
  atk: "atk",
  Defense: "def",
  Def: "def",
  def: "def",
  "Special Attack": "spa",
  SpA: "spa",
  SAtk: "spa",
  SpAtk: "spa",
  spa: "spa",
  Special: "spa",
  spc: "spa",
  Spc: "spa",
  "Special Defense": "spd",
  SpD: "spd",
  SDef: "spd",
  SpDef: "spd",
  spd: "spd",
  Speed: "spe",
  Spe: "spe",
  Spd: "spe",
  spe: "spe"
};
var DISPLAY = {
  hp: ["HP", "HP"],
  atk: ["Atk", "Attack"],
  def: ["Def", "Defense"],
  spa: ["SpA", "Special Attack"],
  spd: ["SpD", "Special Defense"],
  spe: ["Spe", "Speed"],
  spc: ["Spc", "Special"]
};
var Stats = class {
  constructor(dex) {
    this.dex = dex;
  }
  calc(stat, base, iv = 31, ev, level = 100, nature) {
    if (ev === void 0) ev = this.dex.gen < 3 ? 252 : 0;
    if (this.dex.gen < 3) {
      iv = this.toDV(iv) * 2;
      nature = void 0;
    }
    if (stat === "hp") {
      return base === 1 ? base : tr(tr(2 * base + iv + tr(ev / 4) + 100) * level / 100 + 10);
    } else {
      const val = tr(tr(2 * base + iv + tr(ev / 4)) * level / 100 + 5);
      if (nature !== void 0) {
        if (nature.plus === stat) return tr(tr(val * 110, 16) / 100);
        if (nature.minus === stat) return tr(tr(val * 90, 16) / 100);
      }
      return val;
    }
  }
  get(s) {
    return NAMES[s];
  }
  display(str, full = false) {
    let s = NAMES[str];
    if (s === void 0) return str;
    if (this.dex.gen === 1 && s === "spa") s = "spc";
    return DISPLAY[s][+full];
  }
  fill(stats, val) {
    for (const stat of STATS) {
      if (!(stat in stats)) stats[stat] = val;
    }
    return stats;
  }
  getHPDV(ivs) {
    return this.toDV(ivs.atk === void 0 ? 31 : ivs.atk) % 2 * 8 + this.toDV(ivs.def === void 0 ? 31 : ivs.def) % 2 * 4 + this.toDV(ivs.spe === void 0 ? 31 : ivs.spe) % 2 * 2 + this.toDV(ivs.spa === void 0 ? 31 : ivs.spa) % 2;
  }
  *[Symbol.iterator]() {
    for (const s of STATS) {
      yield s;
    }
  }
  toDV(iv) {
    return Math.floor(iv / 2);
  }
  toIV(dv) {
    return dv * 2 + 1;
  }
};
export {
  Abilities,
  Conditions,
  Generation,
  Generations,
  Items,
  Learnsets,
  Moves,
  Natures,
  Specie,
  Species,
  Stats,
  Type,
  Types,
  toID
};
//# sourceMappingURL=index.mjs.map