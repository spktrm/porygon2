{"version":3,"sources":["../index.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  AbilityName,\n  Condition,\n  Data,\n  Dex,\n  Species as DexSpecies,\n  Type as DexType,\n  EggGroup,\n  EvoType,\n  FormeName,\n  GenderName,\n  GenerationNum,\n  ID,\n  ItemName,\n  Move,\n  MoveCategory,\n  MoveName,\n  MoveSource,\n  Nature,\n  Nonstandard,\n  SpeciesAbility,\n  SpeciesName,\n  SpeciesTag,\n  StatID,\n  StatsTable,\n  Tier,\n  TypeName,\n} from '@pkmn/dex-types';\n\nconst DEFAULT_EXISTS = (d: Data) => {\n  if (!d.exists) return false;\n  if ('isNonstandard' in d && d.isNonstandard) return false;\n  if (d.kind === 'Ability' && d.id === 'noability') return false;\n  return !('tier' in d && ['Illegal', 'Unreleased'].includes(d.tier));\n};\n\nconst tr = (num: number, bits = 0) => bits ? (num >>> 0) % (2 ** bits) : num >>> 0;\n\nexport type ExistsFn = (d: Data, g: GenerationNum) => boolean;\ntype BoundExistsFn = (d: Data) => boolean;\n\nfunction assignWithout(a: {[key: string]: any}, b: {[key: string]: any}, exclude: Set<string>) {\n  for (const key in b) {\n    if (Object.prototype.hasOwnProperty.call(b, key) && !exclude.has(key)) {\n      a[key] = b[key];\n    }\n  }\n  return a;\n}\n\nexport function toID(text: any): ID {\n  if (text?.id) text = text.id;\n  if (typeof text !== 'string' && typeof text !== 'number') return '';\n  return ('' + text).toLowerCase().replace(/[^a-z0-9]+/g, '') as ID;\n}\n\nexport class Generations {\n  /* private */ readonly cache = Object.create(null) as {[num: number]: Generation};\n\n  /* private */ readonly dex: Dex;\n  /* private */ readonly exists: ExistsFn;\n\n  static DEFAULT_EXISTS = DEFAULT_EXISTS;\n\n  constructor(dex: Dex, exists = Generations.DEFAULT_EXISTS) {\n    this.dex = dex;\n    this.exists = exists;\n  }\n\n  get(g: string | number) {\n    // May not actually be a GenerationNum, but isNaN and Dex.forGen will validate the rest\n    const gen = (typeof g === 'string' ? parseInt(g.slice(g.search(/\\d/))) : g) as GenerationNum;\n    if (isNaN(+gen)) throw new Error(`Invalid gen ${g}`);\n    if (this.cache[gen]) return this.cache[gen];\n    return (this.cache[gen] = new Generation(this.dex.forGen(gen), d => this.exists(d, gen)));\n  }\n\n  *[Symbol.iterator]() {\n    for (let gen = 1; gen <= 9; gen++) {\n      yield this.get(gen as GenerationNum);\n    }\n  }\n}\n\nexport class Generation {\n  readonly abilities: Abilities;\n  readonly items: Items;\n  readonly moves: Moves;\n  readonly species: Species;\n  readonly types: Types;\n  readonly natures: Natures;\n  readonly learnsets: Learnsets;\n  readonly conditions: Conditions;\n  readonly stats: Stats;\n\n  readonly dex: Dex;\n\n  /* private */ readonly exists: BoundExistsFn;\n\n  static get(dex: Dex, g: string | number, exists = DEFAULT_EXISTS) {\n    return new Generations(dex, exists).get(g);\n  }\n\n  constructor(dex: Dex, exists: BoundExistsFn) {\n    this.dex = dex;\n    this.exists = exists;\n\n    this.abilities = new Abilities(this.dex, this.exists);\n    this.items = new Items(this.dex, this.exists);\n    this.moves = new Moves(this.dex, this.exists);\n    this.species = new Species(this.dex, this.exists);\n    this.natures = new Natures(this.dex, this.exists);\n    this.types = new Types(this.dex, this.exists);\n    this.learnsets = new Learnsets(this, this.dex, this.exists);\n    this.conditions = new Conditions(this.dex, this.exists);\n    this.stats = new Stats(this.dex);\n  }\n\n  get num() {\n    return this.dex.gen;\n  }\n\n  toString() {\n    return `[Generation:${this.num}]`;\n  }\n\n  toJSON() {\n    return this.toString();\n  }\n}\n\nexport class Abilities {\n  /* private */ readonly dex: Dex;\n  /* private */ readonly exists: BoundExistsFn;\n\n  constructor(dex: Dex, exists: BoundExistsFn) {\n    this.dex = dex;\n    this.exists = exists;\n  }\n\n  get(name: string) {\n    const ability = this.dex.abilities.get(name);\n    return this.exists(ability) ? ability : undefined;\n  }\n\n  *[Symbol.iterator]() {\n    for (const ability in this.dex.data.Abilities) {\n      const a = this.get(ability);\n      if (a) yield a;\n    }\n  }\n}\n\nexport class Items {\n  /* private */ readonly dex: Dex;\n  /* private */ readonly exists: BoundExistsFn;\n\n  constructor(dex: Dex, exists: BoundExistsFn) {\n    this.dex = dex;\n    this.exists = exists;\n  }\n\n  get(name: string) {\n    const item = this.dex.items.get(name);\n    return this.exists(item) ? item : undefined;\n  }\n\n  *[Symbol.iterator]() {\n    for (const item in this.dex.data.Items) {\n      const i = this.get(item);\n      if (i) yield i;\n    }\n  }\n}\n\nexport class Moves {\n  /* private */ readonly dex: Dex;\n  /* private */ readonly exists: BoundExistsFn;\n\n  constructor(dex: Dex, exists: BoundExistsFn) {\n    this.dex = dex;\n    this.exists = exists;\n  }\n\n  get(name: string) {\n    const move = this.dex.moves.get(name);\n    return this.exists(move) ? move : undefined;\n  }\n\n  *[Symbol.iterator]() {\n    for (const move in this.dex.data.Moves) {\n      const m = this.get(move);\n      if (m) yield m;\n    }\n  }\n}\n\nexport class Species {\n  /* private */ readonly cache = Object.create(null) as {[id: string]: Specie};\n\n  /* private */ readonly dex: Dex;\n  /* private */ readonly exists: BoundExistsFn;\n\n  constructor(dex: Dex, exists: BoundExistsFn) {\n    this.dex = dex;\n    this.exists = exists;\n  }\n\n  get(name: string) {\n    const species = this.dex.species.get(name);\n    if (!this.exists(species)) return undefined;\n    const id = (species as any).speciesid || species.id; // FIXME Event-only ability hack\n    const cached = this.cache[id];\n    if (cached) return cached;\n    return (this.cache[id] = new Specie(this.dex, this.exists, species));\n  }\n\n  *[Symbol.iterator]() {\n    for (const species in this.dex.data.Species) {\n      const s = this.get(species);\n      if (s) yield s;\n    }\n  }\n}\n\nexport class Specie implements DexSpecies {\n  readonly id!: ID;\n  readonly name!: SpeciesName;\n  readonly fullname!: string;\n  readonly exists!: boolean;\n  readonly num!: number;\n  readonly gen!: GenerationNum;\n  readonly shortDesc!: string;\n  readonly desc!: string;\n  readonly isNonstandard!: Nonstandard | null;\n  readonly duration?: number;\n\n  readonly effectType!: 'Pokemon';\n  readonly kind!: 'Species';\n  readonly baseStats!: StatsTable;\n  readonly baseSpecies!: SpeciesName;\n  readonly baseForme!: FormeName | '';\n  readonly forme!: FormeName | '';\n  readonly abilities!: SpeciesAbility<AbilityName | ''>;\n  readonly types!: [TypeName] | [TypeName, TypeName];\n  readonly prevo?: SpeciesName | '';\n  readonly evos?: SpeciesName[];\n  readonly nfe: boolean;\n  readonly eggGroups!: EggGroup[];\n  readonly weightkg!: number;\n  readonly weighthg!: number;\n  readonly tags!: SpeciesTag[];\n  readonly unreleasedHidden!: boolean | 'Past';\n  readonly maleOnlyHidden!: boolean;\n  readonly inheritsFrom!: ID;\n  readonly tier!: Tier.Singles | Tier.Other;\n  readonly doublesTier!: Tier.Doubles;\n\n  readonly changesFrom?: SpeciesName;\n  readonly cosmeticFormes?: SpeciesName[];\n  readonly otherFormes?: SpeciesName[];\n  readonly formeOrder?: SpeciesName[];\n  readonly formes?: SpeciesName[];\n  readonly genderRatio: {M: number; F: number};\n  readonly isMega?: boolean;\n  readonly isPrimal?: boolean;\n  readonly battleOnly?: SpeciesName | SpeciesName[];\n  readonly canGigantamax?: MoveName;\n  readonly gmaxUnreleased?: boolean;\n  readonly cannotDynamax?: boolean;\n  readonly requiredAbility?: AbilityName;\n  readonly requiredItem?: ItemName;\n  readonly requiredItems?: ItemName[];\n  readonly requiredMove?: MoveName;\n  readonly gender?: GenderName;\n  readonly maxHP?: number;\n  readonly evoMove?: MoveName;\n  readonly evoItem?: string;\n  readonly evoRegion?: 'Alola' | 'Galar';\n  readonly evoLevel?: number;\n  readonly evoCondition?: string;\n  readonly evoType?: EvoType;\n  readonly condition?: Partial<Condition>;\n  readonly canHatch!: boolean;\n\n  /* private */ readonly dex: Dex;\n\n  /* private */ static readonly EXCLUDE = new Set([\n    'abilities', 'cosmeticFormes', 'evos', 'formeOrder',\n    'gender', 'genderRatio', 'nfe', 'otherFormes', 'prevo',\n  ]);\n\n  constructor(dex: Dex, exists: BoundExistsFn, species: DexSpecies) {\n    assignWithout(this, species, Specie.EXCLUDE);\n    this.dex = dex;\n    if (this.dex.gen >= 2) {\n      this.gender = species.gender;\n      this.genderRatio = species.genderRatio;\n    } else {\n      this.genderRatio = {M: 0, F: 0};\n    }\n    if (this.dex.gen >= 3) {\n      this.abilities = {0: species.abilities[0]};\n      // \"because PS\", Pokemon have the abilities that were added in Gen 4 in Gen 3 :bigthonk:\n      if (species.abilities[1] &&\n          this.dex.abilities.get(species.abilities[1]).gen <= this.dex.gen) {\n        this.abilities[1] = species.abilities[1];\n      }\n      if (this.dex.gen >= 5 && species.abilities.H) this.abilities.H = species.abilities.H;\n      if (this.dex.gen >= 7 && species.abilities.S) this.abilities.S = species.abilities.S;\n    } else {\n      this.abilities = {0: ''};\n    }\n    this.evos = species.evos?.filter(s => exists(this.dex.species.get(s)));\n    this.nfe = !!this.evos?.length;\n    if (!this.nfe) this.evos = undefined;\n    this.cosmeticFormes = species.cosmeticFormes?.filter(s => exists(this.dex.species.get(s)));\n    if (!this.cosmeticFormes?.length) this.cosmeticFormes = undefined;\n    this.otherFormes = species.otherFormes?.filter(s => exists(this.dex.species.get(s)));\n    if (!this.otherFormes?.length) this.otherFormes = undefined;\n    this.formeOrder = species.formeOrder?.filter(s => exists(this.dex.species.get(s)));\n    if (!this.formeOrder || this.formeOrder.length <= 1) this.formeOrder = undefined;\n    this.formes = this.formeOrder?.filter(s =>\n      this.dex.species.get(s).isNonstandard !== 'Gigantamax');\n    this.prevo =\n      species.prevo && exists(this.dex.species.get(species.prevo)) ? species.prevo : undefined;\n  }\n\n  get formeNum() {\n    return (this.baseSpecies === this.name\n      ? this.formeOrder ? this.formeOrder.findIndex(name => name === this.name) : 0\n      : this.dex.species.get(this.baseSpecies).formeOrder!.findIndex(\n        name => name === (this.isNonstandard === 'Gigantamax' ? this.baseSpecies : this.name)\n      ));\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return assignWithout({}, this, new Set(['dex']));\n  }\n}\n\nexport class Conditions {\n  /* private */ readonly dex: Dex;\n  /* private */ readonly exists: BoundExistsFn;\n\n  constructor(dex: Dex, exists: BoundExistsFn) {\n    this.dex = dex;\n    this.exists = exists;\n  }\n\n  get(name: string) {\n    const condition = this.dex.conditions.get(name);\n    return this.exists(condition) ? condition : undefined;\n  }\n}\n\nexport class Natures {\n  /* private */ readonly dex: Dex;\n  /* private */ readonly exists: BoundExistsFn;\n\n  constructor(dex: Dex, exists: BoundExistsFn) {\n    this.dex = dex;\n    this.exists = exists;\n  }\n\n  get(name: string) {\n    if (this.dex.gen < 3) return undefined;\n    const nature = this.dex.natures.get(name);\n    return this.exists(nature) ? nature : undefined;\n  }\n\n  *[Symbol.iterator]() {\n    for (const nature in this.dex.data.Natures) {\n      const n = this.get(nature);\n      if (n) yield n;\n    }\n  }\n}\n\nconst EFFECTIVENESS = {\n  '-3': 0.125,\n  '-2': 0.25,\n  '-1': 0.5,\n  '0': 1,\n  '1': 2,\n  '2': 4,\n  '3': 8,\n};\n\ntype TypeTarget = {getTypes: () => TypeName[]} | {types: TypeName[]} | TypeName[] | TypeName;\n\nexport class Types {\n  /* private */ readonly cache = Object.create(null) as {[id: string]: Type};\n\n  /* private */ readonly unknown: Type;\n  /* private */ readonly dex: Dex;\n  /* private */ readonly exists: BoundExistsFn;\n\n  constructor(dex: Dex, exists: BoundExistsFn) {\n    this.dex = dex;\n    this.exists = exists;\n    // PS doesn't contain data for the '???' type\n    this.unknown = new Type({\n      effectType: 'Type',\n      kind: 'Type',\n      // Regrettably PS ID's can't represent '???'\n      id: '',\n      name: '???',\n      // Technically this only exists as a true type in Gens 2-4, but there are moves dealing\n      // typeless damage in Gen 1 so we include it there.\n      exists: dex.gen <= 4,\n      gen: 1,\n      // This gets filled in for us by Type's constructor\n      damageTaken: {} as {[t in Exclude<TypeName, '???'>]: number},\n      HPivs: {},\n      HPdvs: {},\n    }, dex, this);\n  }\n\n  get(name: string) {\n    if (name === '???') return this.unknown;\n    const type = this.dex.types.get(name);\n    if (!this.exists(type)) return undefined;\n    const cached = this.cache[type.id];\n    if (cached) return cached;\n    return (this.cache[type.id] = new Type(type, this.dex, this));\n  }\n\n  *[Symbol.iterator]() {\n    for (const type in this.dex.data.Types) {\n      const t = this.get(type);\n      if (t) yield t;\n    }\n    if (this.dex.gen >= 2 && this.dex.gen <= 4) {\n      yield this.unknown;\n    }\n  }\n\n  getHiddenPower(ivs: StatsTable) {\n    return this.dex.getHiddenPower(ivs);\n  }\n\n  canDamage(source: {type: TypeName} | TypeName, target: TypeTarget) {\n    return this.dex.getImmunity(source, target);\n  }\n\n  totalEffectiveness(source: {type: TypeName} | TypeName, target: TypeTarget) {\n    if (!this.canDamage(source, target)) return 0;\n    const e = `${this.dex.getEffectiveness(source, target)}`;\n    // convert from PS's ridiculous encoding to something usable\n    return EFFECTIVENESS[e as keyof typeof EFFECTIVENESS];\n  }\n}\n\nexport type TypeEffectiveness = 0 | 0.5 | 1 | 2;\n\nconst DAMAGE_TAKEN = [1, 2, 0.5, 0] as TypeEffectiveness[];\nconst SPECIAL = ['Fire', 'Water', 'Grass', 'Electric', 'Ice', 'Psychic', 'Dark', 'Dragon'];\n\nexport class Type {\n  readonly id!: ID;\n  readonly name!: TypeName;\n  readonly effectType!: 'Type';\n  readonly kind!: 'Type';\n  readonly exists!: boolean;\n  readonly gen!: GenerationNum;\n  readonly effectiveness: {[t in TypeName]: TypeEffectiveness};\n  readonly HPivs!: Partial<StatsTable>;\n  readonly HPdvs!: Partial<StatsTable>;\n  readonly category?: Exclude<MoveCategory, 'Status'>;\n\n  /* private */ readonly types: Types;\n\n  constructor(type: DexType, dex: Dex, types: Types) {\n    Object.assign(this, type);\n    this.types = types;\n    this.category =\n      this.name === 'Fairy' ? undefined : SPECIAL.includes(this.name) ? 'Special' : 'Physical';\n    // convert from PS's ridiculous encoding to something usable (plus damage taken -> dealt)\n    this.effectiveness = {'???': 1} as {[t in TypeName]: TypeEffectiveness};\n    for (const k in dex.data.Types) {\n      const t = k.charAt(0).toUpperCase() + k.slice(1) as Exclude<TypeName, '???'>;\n      this.effectiveness[t] = DAMAGE_TAKEN[dex.data.Types[k].damageTaken[this.name] || 0];\n    }\n  }\n\n  canDamage(target: TypeTarget) {\n    return this.types.canDamage(this.name, target);\n  }\n\n  totalEffectiveness(target: TypeTarget) {\n    return this.types.totalEffectiveness(this.name, target);\n  }\n\n  toString() {\n    return this.name;\n  }\n\n  toJSON() {\n    return assignWithout({}, this, new Set(['types']));\n  }\n}\n\nconst GEN3_HMS =\n  new Set(['cut', 'fly', 'surf', 'strength', 'flash', 'rocksmash', 'waterfall', 'dive'] as ID[]);\n// NOTE: Whirlpool and Defog are Gen 4 HMs but the HMs differ in DPPt vs. HGSS\nconst GEN4_HMS =\n  new Set(['cut', 'fly', 'surf', 'strength', 'rocksmash', 'waterfall', 'rockclimb'] as ID[]);\n\ntype Restriction = 'Pentagon' | 'Plus' | 'Galar' | 'Paldea';\n\nexport class Learnsets {\n  /* private */ readonly cache = Object.create(null) as {\n    [speciesid: string]: {[moveid: string]: MoveSource[]};\n  };\n\n  /* private */ readonly gen: Generation;\n  /* private */ readonly dex: Dex;\n  /* private */ readonly exists: BoundExistsFn;\n\n  constructor(gen: Generation, dex: Dex, exists: BoundExistsFn) {\n    this.gen = gen;\n    this.dex = dex;\n    this.exists = exists;\n  }\n\n  async get(name: string) {\n    const learnset = await this.dex.learnsets.get(toID(name));\n    return this.exists(learnset) ? learnset : undefined;\n  }\n\n  async *[Symbol.iterator]() {\n    if (!this.dex.data.Learnsets) await this.dex.learnsets.get('LOAD' as ID);\n    for (const id in this.dex.data.Learnsets) {\n      const l = await this.get(id);\n      if (l) yield l;\n    }\n  }\n\n  async* all(species: Specie) {\n    let id = species.id;\n    let learnset = await this.get(id);\n    if (!learnset) {\n      id = typeof species.battleOnly === 'string' && species.battleOnly !== species.baseSpecies\n        ? toID(species.battleOnly)\n        : toID(species.baseSpecies);\n      learnset = await this.get(id);\n    }\n\n    while (learnset) {\n      yield learnset;\n\n      if (id === 'lycanrocdusk' || (species.id === 'rockruff' && id === 'rockruff')) {\n        id = 'rockruffdusk' as ID;\n      } else if (species.id === 'gastrodoneast') {\n        id = 'gastrodon' as ID;\n      } else if (species.id === 'pumpkaboosuper') {\n        id = 'pumpkaboo' as ID;\n      } else {\n        id = toID(species.battleOnly || species.changesFrom || species.prevo);\n      }\n\n      if (!id) break;\n      const s = this.gen.species.get(id);\n      if (!s) break;\n      species = s;\n      learnset = await this.get(id);\n    }\n  }\n\n  // BUG: this only covers what Pokémon Showdown deems \"teambuilder legality\" - proper legality\n  // checks/restriction enforcement requires @pkmn/sim's TeamValidator.\n  async learnable(name: string, restriction?: Restriction) {\n    const species = this.gen.species.get(name);\n    if (!species) return undefined;\n\n    if (!restriction) {\n      const cached = this.cache[species.id];\n      if (cached) return cached;\n    }\n\n    const moves: {[moveid: string]: MoveSource[]} = {};\n\n    for await (const learnset of this.all(species)) {\n      if (learnset.learnset) {\n        for (const moveid in learnset.learnset) {\n          const move = this.gen.moves.get(moveid);\n          if (move) {\n            const sources = learnset.learnset[moveid];\n            if (this.isLegal(move, sources, restriction || this.gen)) {\n              const filtered = sources.filter(s => +s.charAt(0) <= this.gen.num);\n              if (!filtered.length) continue;\n              if (moves[move.id]) {\n                // If we simply add filtered to moves[move.id] we may end up with some duplicates or\n                // situations where we have mixed learnset information. We assume that while\n                // moves[move.id] and filtered are already deduped, their union might not be, and\n                // thus iterate through looking for unique prefixes. For efficiency, instead of\n                // appending each deduped source from filtered to moves[move.id] immediately and\n                // making each subsequent iteration longer we make a list of the unique sources to\n                // add at the end. This is only safe given our assumption that filtered is unique\n                // internally to begin with.\n                const unique = [];\n                // These lists are all expected to be short arrays so this O(n^2) linear searching\n                // is still expected to be faster runtime-wise than a more sophisticated approach\n                loop: for (const source of filtered) {\n                  const prefix = source.slice(0, 2);\n                  // sadly Babel chokes on using an .every(...) here due to throwIfClosureRequired\n                  for (const s of moves[move.id]) if (s.startsWith(prefix)) continue loop;\n                  unique.push(source);\n                }\n                moves[move.id].push(...unique);\n              } else {\n                moves[move.id] = filtered;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (!restriction) this.cache[species.id] = moves;\n    return moves;\n  }\n\n  // BUG: this only covers what Pokémon Showdown deems \"teambuilder legality\" - proper legality\n  // checks/restriction enforcement requires @pkmn/sim's TeamValidator.\n  async canLearn(name: string, move: Move | string, restriction?: Restriction) {\n    const species = this.gen.species.get(name);\n    if (!species) return false;\n\n    move = typeof move === 'string' && this.gen.moves.get(move) || move;\n    if (typeof move === 'string') return false;\n\n    for await (const learnset of this.all(species)) {\n      if (this.isLegal(move, learnset.learnset?.[move.id], restriction || this.gen)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // BUG: this only covers what Pokémon Showdown deems \"teambuilder legality\" - proper legality\n  // checks/restriction enforcement requires @pkmn/sim's TeamValidator.\n  isLegal(move: Move, sources: MoveSource[] | undefined, gen: Generation | Restriction) {\n    if (!sources) return undefined;\n\n    const gens = sources.map(x => Number(x[0]));\n    const minGen = Math.min(...gens);\n    const vcOnly = (\n      minGen === 7 && sources.every(x => x[0] !== '7' || x === '7V') ||\n      minGen === 8 && sources.every(x => x[0] !== '8' || x === '8V')\n    );\n\n    if (gen === 'Pentagon') return gens.includes(6);\n    if (gen === 'Plus') return gens.includes(7) && !vcOnly;\n    if (gen === 'Galar') return gens.includes(8) && !vcOnly;\n    if (gen === 'Paldea') return gens.includes(9);\n\n    if (this.gen.num >= 3 && minGen <= 4 && (GEN3_HMS.has(move.id) || GEN4_HMS.has(move.id))) {\n      let legalGens = '';\n      let available = false;\n\n      if (minGen === 3) {\n        legalGens += '3';\n        available = true;\n      }\n      if (available) available = !GEN3_HMS.has(move.id);\n\n      if (available || gens.includes(4)) {\n        legalGens += '4';\n        available = true;\n      }\n      if (available) available = !GEN4_HMS.has(move.id);\n\n      const minUpperGen = available ? 5 : Math.min(...gens.filter(g => g > 4));\n      legalGens += '0123456789'.slice(minUpperGen);\n      return legalGens.includes(`${gen.num}`);\n    } else {\n      return '0123456789'.slice(minGen).includes(`${gen.num}`);\n    }\n  }\n}\n\nconst STATS = ['hp', 'atk', 'def', 'spe', 'spa', 'spd'] as const;\n\nconst NAMES: Readonly<{[name: string]: StatID}> = {\n  HP: 'hp', hp: 'hp',\n  Attack: 'atk', Atk: 'atk', atk: 'atk',\n  Defense: 'def', Def: 'def', def: 'def',\n  'Special Attack': 'spa', SpA: 'spa', SAtk: 'spa', SpAtk: 'spa', spa: 'spa',\n  Special: 'spa', spc: 'spa', Spc: 'spa',\n  'Special Defense': 'spd', SpD: 'spd', SDef: 'spd', SpDef: 'spd', spd: 'spd',\n  Speed: 'spe', Spe: 'spe', Spd: 'spe', spe: 'spe',\n};\n\nconst DISPLAY: Readonly<{[stat: string]: Readonly<[string, string]>}> = {\n  hp: ['HP', 'HP'],\n  atk: ['Atk', 'Attack'],\n  def: ['Def', 'Defense'],\n  spa: ['SpA', 'Special Attack'],\n  spd: ['SpD', 'Special Defense'],\n  spe: ['Spe', 'Speed'],\n  spc: ['Spc', 'Special'],\n};\n\nexport class Stats {\n  /* private */ readonly dex: Dex;\n\n  constructor(dex: Dex) {\n    this.dex = dex;\n  }\n\n  calc(stat: StatID, base: number, iv = 31, ev?: number, level = 100, nature?: Nature) {\n    if (ev === undefined) ev = this.dex.gen < 3 ? 252 : 0;\n    if (this.dex.gen < 3) {\n      iv = this.toDV(iv) * 2;\n      nature = undefined;\n    }\n    if (stat === 'hp') {\n      return base === 1 ? base : tr(tr(2 * base + iv + tr(ev / 4) + 100) * level / 100 + 10);\n    } else {\n      const val = tr(tr(2 * base + iv + tr(ev / 4)) * level / 100 + 5);\n      if (nature !== undefined) {\n        if (nature.plus === stat) return tr(tr(val * 110, 16) / 100);\n        if (nature.minus === stat) return tr(tr(val * 90, 16) / 100);\n      }\n      return val;\n    }\n  }\n\n  get(s: string): StatID | undefined {\n    return NAMES[s];\n  }\n\n  display(str: string, full = false): string {\n    let s: StatID | 'spc' | undefined = NAMES[str];\n    if (s === undefined) return str;\n    if (this.dex.gen === 1 && s === 'spa') s = 'spc';\n    return DISPLAY[s][+full];\n  }\n\n  fill<T>(stats: Partial<StatsTable<T>>, val: T): StatsTable<T> {\n    for (const stat of STATS) {\n      if (!(stat in stats)) stats[stat] = val;\n    }\n    return stats as StatsTable<T>;\n  }\n\n  getHPDV(ivs: Partial<StatsTable>): number {\n    return (\n      (this.toDV(ivs.atk === undefined ? 31 : ivs.atk) % 2) * 8 +\n      (this.toDV(ivs.def === undefined ? 31 : ivs.def) % 2) * 4 +\n      (this.toDV(ivs.spe === undefined ? 31 : ivs.spe) % 2) * 2 +\n      (this.toDV(ivs.spa === undefined ? 31 : ivs.spa) % 2)\n    );\n  }\n\n  *[Symbol.iterator](): IterableIterator<StatID> {\n    for (const s of STATS) {\n      yield s;\n    }\n  }\n\n  toDV(iv: number): number {\n    return Math.floor(iv / 2);\n  }\n\n  toIV(dv: number): number {\n    return dv * 2 + 1;\n  }\n}\n\nexport type {\n  ID,\n  As,\n  Weather,\n  FieldCondition,\n  SideCondition,\n  GenerationNum,\n  GenderName,\n  StatID,\n  StatsTable,\n  BoostID,\n  BoostsTable,\n  MoveCategory,\n  MoveTarget,\n  Nonstandard,\n  EvoType,\n  EggGroup,\n  SideID,\n  Player,\n  GameType,\n  HPColor,\n  StatusName,\n  NatureName,\n  TypeName,\n  HPTypeName,\n  Tier,\n  PokemonSet,\n  AbilityName,\n  ItemName,\n  MoveName,\n  SpeciesName,\n  FormeName,\n  EffectType,\n  Effect,\n  DataKind,\n  Data,\n  EffectData,\n  HitEffect,\n  SecondaryEffect,\n  ConditionData,\n  AbilityData,\n  ItemData,\n  MoveData,\n  SpeciesData,\n  MoveSource,\n  EventInfoData,\n  LearnsetData,\n  TypeData,\n  NatureData,\n  BasicEffect,\n  Condition,\n  Ability,\n  Item,\n  Move,\n  // Species,\n  EventInfo,\n  Learnset,\n  // Type,\n  Nature,\n  GenID,\n  Dex,\n} from '@pkmn/dex-types';\n"]}