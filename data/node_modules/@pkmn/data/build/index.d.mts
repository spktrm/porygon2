import * as _pkmn_dex_types from '@pkmn/dex-types';
import { Data, GenerationNum, ID, Dex, Move, Species as Species$1, SpeciesName, Nonstandard, StatsTable, FormeName, SpeciesAbility, AbilityName, TypeName, EggGroup, SpeciesTag, Tier, MoveName, ItemName, GenderName, EvoType, Condition, Nature, MoveCategory, Type as Type$1, MoveSource, StatID } from '@pkmn/dex-types';
export { Ability, AbilityData, AbilityName, As, BasicEffect, BoostID, BoostsTable, Condition, ConditionData, Data, DataKind, Dex, Effect, EffectData, EffectType, EggGroup, EventInfo, EventInfoData, EvoType, FieldCondition, FormeName, GameType, GenID, GenderName, GenerationNum, HPColor, HPTypeName, HitEffect, ID, Item, ItemData, ItemName, Learnset, LearnsetData, Move, MoveCategory, MoveData, MoveName, MoveSource, MoveTarget, Nature, NatureData, NatureName, Nonstandard, Player, PokemonSet, SecondaryEffect, SideCondition, SideID, SpeciesData, SpeciesName, StatID, StatsTable, StatusName, Tier, TypeData, TypeName, Weather } from '@pkmn/dex-types';

type ExistsFn = (d: Data, g: GenerationNum) => boolean;
type BoundExistsFn = (d: Data) => boolean;
declare function toID(text: any): ID;
declare class Generations {
    readonly cache: {
        [num: number]: Generation;
    };
    readonly dex: Dex;
    readonly exists: ExistsFn;
    static DEFAULT_EXISTS: (d: Data) => boolean;
    constructor(dex: Dex, exists?: (d: Data) => boolean);
    get(g: string | number): Generation;
    [Symbol.iterator](): Generator<Generation, void, unknown>;
}
declare class Generation {
    readonly abilities: Abilities;
    readonly items: Items;
    readonly moves: Moves;
    readonly species: Species;
    readonly types: Types;
    readonly natures: Natures;
    readonly learnsets: Learnsets;
    readonly conditions: Conditions;
    readonly stats: Stats;
    readonly dex: Dex;
    readonly exists: BoundExistsFn;
    static get(dex: Dex, g: string | number, exists?: (d: Data) => boolean): Generation;
    constructor(dex: Dex, exists: BoundExistsFn);
    get num(): GenerationNum;
    toString(): string;
    toJSON(): string;
}
declare class Abilities {
    readonly dex: Dex;
    readonly exists: BoundExistsFn;
    constructor(dex: Dex, exists: BoundExistsFn);
    get(name: string): _pkmn_dex_types.Ability | undefined;
    [Symbol.iterator](): Generator<_pkmn_dex_types.Ability, void, unknown>;
}
declare class Items {
    readonly dex: Dex;
    readonly exists: BoundExistsFn;
    constructor(dex: Dex, exists: BoundExistsFn);
    get(name: string): _pkmn_dex_types.Item | undefined;
    [Symbol.iterator](): Generator<_pkmn_dex_types.Item, void, unknown>;
}
declare class Moves {
    readonly dex: Dex;
    readonly exists: BoundExistsFn;
    constructor(dex: Dex, exists: BoundExistsFn);
    get(name: string): Move | undefined;
    [Symbol.iterator](): Generator<Move, void, unknown>;
}
declare class Species {
    readonly cache: {
        [id: string]: Specie;
    };
    readonly dex: Dex;
    readonly exists: BoundExistsFn;
    constructor(dex: Dex, exists: BoundExistsFn);
    get(name: string): Specie | undefined;
    [Symbol.iterator](): Generator<Specie, void, unknown>;
}
declare class Specie implements Species$1 {
    readonly id: ID;
    readonly name: SpeciesName;
    readonly fullname: string;
    readonly exists: boolean;
    readonly num: number;
    readonly gen: GenerationNum;
    readonly shortDesc: string;
    readonly desc: string;
    readonly isNonstandard: Nonstandard | null;
    readonly duration?: number;
    readonly effectType: 'Pokemon';
    readonly kind: 'Species';
    readonly baseStats: StatsTable;
    readonly baseSpecies: SpeciesName;
    readonly baseForme: FormeName | '';
    readonly forme: FormeName | '';
    readonly abilities: SpeciesAbility<AbilityName | ''>;
    readonly types: [TypeName] | [TypeName, TypeName];
    readonly prevo?: SpeciesName | '';
    readonly evos?: SpeciesName[];
    readonly nfe: boolean;
    readonly eggGroups: EggGroup[];
    readonly weightkg: number;
    readonly weighthg: number;
    readonly tags: SpeciesTag[];
    readonly unreleasedHidden: boolean | 'Past';
    readonly maleOnlyHidden: boolean;
    readonly inheritsFrom: ID;
    readonly tier: Tier.Singles | Tier.Other;
    readonly doublesTier: Tier.Doubles;
    readonly changesFrom?: SpeciesName;
    readonly cosmeticFormes?: SpeciesName[];
    readonly otherFormes?: SpeciesName[];
    readonly formeOrder?: SpeciesName[];
    readonly formes?: SpeciesName[];
    readonly genderRatio: {
        M: number;
        F: number;
    };
    readonly isMega?: boolean;
    readonly isPrimal?: boolean;
    readonly battleOnly?: SpeciesName | SpeciesName[];
    readonly canGigantamax?: MoveName;
    readonly gmaxUnreleased?: boolean;
    readonly cannotDynamax?: boolean;
    readonly requiredAbility?: AbilityName;
    readonly requiredItem?: ItemName;
    readonly requiredItems?: ItemName[];
    readonly requiredMove?: MoveName;
    readonly gender?: GenderName;
    readonly maxHP?: number;
    readonly evoMove?: MoveName;
    readonly evoItem?: string;
    readonly evoRegion?: 'Alola' | 'Galar';
    readonly evoLevel?: number;
    readonly evoCondition?: string;
    readonly evoType?: EvoType;
    readonly condition?: Partial<Condition>;
    readonly canHatch: boolean;
    readonly dex: Dex;
    static readonly EXCLUDE: Set<string>;
    constructor(dex: Dex, exists: BoundExistsFn, species: Species$1);
    get formeNum(): number;
    toString(): SpeciesName;
    toJSON(): {
        [key: string]: any;
    };
}
declare class Conditions {
    readonly dex: Dex;
    readonly exists: BoundExistsFn;
    constructor(dex: Dex, exists: BoundExistsFn);
    get(name: string): Condition | undefined;
}
declare class Natures {
    readonly dex: Dex;
    readonly exists: BoundExistsFn;
    constructor(dex: Dex, exists: BoundExistsFn);
    get(name: string): Nature | undefined;
    [Symbol.iterator](): Generator<Nature, void, unknown>;
}
type TypeTarget = {
    getTypes: () => TypeName[];
} | {
    types: TypeName[];
} | TypeName[] | TypeName;
declare class Types {
    readonly cache: {
        [id: string]: Type;
    };
    readonly unknown: Type;
    readonly dex: Dex;
    readonly exists: BoundExistsFn;
    constructor(dex: Dex, exists: BoundExistsFn);
    get(name: string): Type | undefined;
    [Symbol.iterator](): Generator<Type, void, unknown>;
    getHiddenPower(ivs: StatsTable): {
        type: TypeName;
        power: number;
    };
    canDamage(source: {
        type: TypeName;
    } | TypeName, target: TypeTarget): boolean;
    totalEffectiveness(source: {
        type: TypeName;
    } | TypeName, target: TypeTarget): number;
}
type TypeEffectiveness = 0 | 0.5 | 1 | 2;
declare class Type {
    readonly id: ID;
    readonly name: TypeName;
    readonly effectType: 'Type';
    readonly kind: 'Type';
    readonly exists: boolean;
    readonly gen: GenerationNum;
    readonly effectiveness: {
        [t in TypeName]: TypeEffectiveness;
    };
    readonly HPivs: Partial<StatsTable>;
    readonly HPdvs: Partial<StatsTable>;
    readonly category?: Exclude<MoveCategory, 'Status'>;
    readonly types: Types;
    constructor(type: Type$1, dex: Dex, types: Types);
    canDamage(target: TypeTarget): boolean;
    totalEffectiveness(target: TypeTarget): number;
    toString(): TypeName;
    toJSON(): {
        [key: string]: any;
    };
}
type Restriction = 'Pentagon' | 'Plus' | 'Galar' | 'Paldea';
declare class Learnsets {
    readonly cache: {
        [speciesid: string]: {
            [moveid: string]: MoveSource[];
        };
    };
    readonly gen: Generation;
    readonly dex: Dex;
    readonly exists: BoundExistsFn;
    constructor(gen: Generation, dex: Dex, exists: BoundExistsFn);
    get(name: string): Promise<_pkmn_dex_types.Learnset | undefined>;
    [Symbol.iterator](): AsyncGenerator<_pkmn_dex_types.Learnset, void, unknown>;
    all(species: Specie): AsyncGenerator<_pkmn_dex_types.Learnset, void, unknown>;
    learnable(name: string, restriction?: Restriction): Promise<{
        [moveid: string]: string[];
    } | undefined>;
    canLearn(name: string, move: Move | string, restriction?: Restriction): Promise<boolean>;
    isLegal(move: Move, sources: MoveSource[] | undefined, gen: Generation | Restriction): boolean | undefined;
}
declare class Stats {
    readonly dex: Dex;
    constructor(dex: Dex);
    calc(stat: StatID, base: number, iv?: number, ev?: number, level?: number, nature?: Nature): number;
    get(s: string): StatID | undefined;
    display(str: string, full?: boolean): string;
    fill<T>(stats: Partial<StatsTable<T>>, val: T): StatsTable<T>;
    getHPDV(ivs: Partial<StatsTable>): number;
    [Symbol.iterator](): IterableIterator<StatID>;
    toDV(iv: number): number;
    toIV(dv: number): number;
}

export { Abilities, Conditions, type ExistsFn, Generation, Generations, Items, Learnsets, Moves, Natures, Specie, Species, Stats, Type, type TypeEffectiveness, Types, toID };
